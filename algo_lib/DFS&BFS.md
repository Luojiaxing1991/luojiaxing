在可信考试中，BFS和DFS是我们在做路径规划，树，图等题目中经常要用到的两种算法，在此做一个简单总结。

# DFS

DFS，深度优先搜索，从名字上理解，这个算法会首先按照预设的规划，找一条路走到尽头（深度优先），到尽头后，再回到尽头的前一个节点，看是否有新的路可以走，同样也是一路走到尽头，再回头到前一个节点。

![Image text](https://github.com/Luojiaxing1991/picture/blob/master/DFS-simple-example.png)

由上图可知，到节点4后会优先探索节点5，如果节点5后面已经无路可走，就会回到节点4，看看节点4是否有其他新路径可走，所幸可以去6，那么会继续去探索6，6后面也无路可走，就会再继续退回，一直到1，才发现有7可以走，那么最后探索7，之后即使一直返回到起点，也没有新路径可走，整个DFS搜索就完成了，也覆盖了所有可能的路径。

因此，DFS很适合用递归进行编码，递归的思路就是需要找到所有对象的共性，写成一个函数，向下递归就是不断调用自己，但是递归要求必须要有一个明确的终点，不可以一直递归下去。

我们可以分析上面那些节点，对于每个节点而言，进入这个节点后，需要优先找有没有路可以通过，如果没有，就返回，如果有，优先向右走，向下次之。

下面是一个简单的递归函数。

```C
void search()
{
  if (no_way_to_go)
    return;

  if (can_go_right)
    search();
  
  if (can_go_down)
    search();
}
```

但是DFS比较适用于单向的路径规划，树等，但是无法适用于有向图，因为如果如果遇到自环回的路径，DFS的设计逻辑会导致代码在这个路径里面不断死循环。举个例子如下：

![Image text](https://github.com/Luojiaxing1991/picture/blob/master/DFS-dead-cycle.png)

所以我们应该引入BFS的概念。

# BFS
BFS是广度优先搜索的概念，区别于DFS一路到底的特性，BFS会优先搜索当前节点周围的所有节点，并保存路径信息，再从周围的节点中挑选一个节点，保留该节点周围的路径信息，就像跑马圈地一样的概念，从某一个点开始，先探索周边，然后到下一个点，继续探索周边。如下：

![Image text](https://github.com/Luojiaxing1991/picture/blob/master/BFS-simple-example.png)

由BFS的队列特性可知，这比较适合用whild循环来写代码，当然也可以递归，但是递归要有队列来控制。也就是说，每次从队列里面pop出一个元素后，就可以递归调用自己，一旦队列为空，那么递归结束。这种递归其实就是while的效果。

```C
void push(node){
  ...
}

int pop(*node){
  ...
}

void search(node){
  for(all_node_around){
    push(node);
  }
  pop(*next);
  search(next);
}
```

BFS主要面向于有向图，而且思路就是跑马圈地，每进入一个节点就会把基于周围节点的情况更新现有路径，而且要防止进入同一节点进行探索，因此需要对节点进行标记。这就保证了BFS不会被自环回影响，导致死循环。

#总结

DFS就是孤军深入，撞到南墙，再返回找路，只要不存在自环回，是可以把全路径都走一遍的。

BFS就是步步为营，一步一步地把路径信息收集好，坚决不重复一个地方进行探索，所以即使自环回，也不受影响。

