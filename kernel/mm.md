# 参考网页

Linux内存管理（最透彻的一篇）
https://www.cnblogs.com/ralap7/p/9184773.html


# 进程的5中数据

代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，
而不允许写入（修改）操作——它是不可写的。

数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量（static）和全局变量。

BSS段：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。

堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，
新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）

栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。
除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。
由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

# 进程内存空间
Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。

## 进程内存管理

linux内核中对应进程内存区域的数据结构是： vm_area_struct, vm_area_struct是描述进程地址空间的基本管理单元，对于一个进程来说往往需要多个内存区域来描述它的虚拟空间。 一个内存区域被限制在4G，所以对于进程，可以通过链表或者红黑树来管理各个内存区域。

### vm_area_struct
内核使用vm_area_struct描述虚拟内存区域。主要成员有：
vm_start，vm_end：  内存区间： [起始地址，结束地址)，不包含结束地址

vm_next,vm_prev,vm_rb等 链表，红黑树的指针

vm_mm: 虚拟内存区域所属的用户虚拟地址空间的内存描述符

vm_ops 虚拟内存操作集合

### vm_operations
虚拟内存操作集合，定义了虚拟内存的各种操作方法，主要有：
1. open 方法： 创建虚拟内存区域
2. close 方法： 删除虚拟内存区域
3. mremap 方法： 移动虚拟内存区域
4. fault 方法： 访问文件映射的虚拟页时，如果没有映射到物理页，生成缺页异常，异常处理函数调用fault方法来把文件的数据读取到文件的页缓存中。
5. huge_fault 方法：

【可以把 Linux内存管理（最透彻的一篇） 中的 进程地址空间的管理模型 这个图粘贴到这里】

## buddy system 伙伴分配器

# what is SVA?

## Nvidia - UVA(Unifi Virtual address)

1. GPU 有独立的MMU
2. CPU只能访问DDR而GPU只能访问HBM
3. GPU MMU与CPU共享 page table
4. 当GPU访问一个不存在与HBM的VA，它会从DDR中拷贝数据

【可以把 Shared_virtual_addressing_+yishen-xie那个文档中 page 5 的图片放到这里】


# Davinci SVM方案
Davinci中 AI core侧和host侧都有独立的 DDR，类似于 Nvidia的方案



